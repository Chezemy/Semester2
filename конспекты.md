<h1>История ОС</h1>
<h3>ЭВМ первого поколения</h3>
ОС пока не существет. В 1943 году появлилась необходимость в увеличении скорости расчета баллистических таблиц, которая составляла 4 года.
Джон Мокли и Джон Эккерт разработали первый компьютер - Эниак(электронный дифференциальный анализатор). Скорость одного расчета - 5 минут. Используются лампы.
Для перепрограммирования используются перемычки. Данные находятся на перфокартах. Используется десятичная система счисления. <br>
<h4>Архитектура фон Неймана</h4>
<ol>
  <li>Переход к двоичной системе исчисления. 1 - есть сигнал. 0 - нет сигнала
  <li>Вместо перфокарт данные хранятся в памяти
  <li>Программы выполняются последовательно
</ol>
<h3>ЭВМ второго поколения</h3>
В 50-х годах появляются транзисторы. Плюсы по сравнению с лампами:
<ol>
  <li> Надежность
  <li> Транзисторы не выделяют тепло
  <li> Большая скорость переключения
  <li>Плотная коомпоновка деталей
</ol>
Недостатки:
<ol>
  <li>Проблемы с соединением
  <li>Дороговизна производства
</ol>
Появление первых алгоротмических языков (COBAL, ALGOL), появление компилятора.
<h3>ЭВМ третьего и четвертого поколения</h3>
Проблемы: Ответить на вопрос - как на полупроводнике разместить все компонетны. Ответ - использовать фотолитографию
Как соеденить между собой элементы. Ответ - напыление алюминия<br>
Плюсы:
<ol>
  <li>Уменьшение цены
  <li>Надежность
  <li>Ускорение ввода
  <li>Появление магнитного диска
  <li>Появление мультипрограммирования
</ol>

Четвертое поколение ЭВМ началось в 70-80 годах:
<ol>
  <li>Появление виртуальной памяти(выполнение нужного участка программы)
  <li>Появление концепции базы данных
  <li>Появление пк - altair 8800
  <li>Появление apple
  <li>Появления linux
</ol>
Идеология Unix:
<ol>
  <li>Программа решает одну задачу
  <li>Программы хорошо работают вместе
  <li>Поддержка текстовых потоков
</ol>
<h4>Linux</h4>
Создатель Linux - Линус Торвальдс<br>
1991 - разработка linux, разработка терминала для получения почты, разработка линус которая запускается Bourne shell<br>
<h4>Функции ОС:</h4>
<ol>
  <li>Выделение программ
  <li>Выделение памяти, загрузка памяти исполняемой программы
  <li>Обработка системных вызовов
  <li>Ввод и вывод данных
</ol>
  Стандартизированный доступ к устройствам ввода и вывода
<ol>
  <li>Обеспечение безопасности
  <li>Организация сетевого стека
</ol>
Монолитное ядро
<ol>
  <li>По сути одна программа
  <li>Одно адресное устройство
  <li>Linux
  <li>UNIX
</ol>
Микроядерная архитектура:
<ol>
  <li>Маленькое ядро
  <li>Юазовое управление памятью
  <li>Управление процессорами времени
</ol>
Совместимость ОС
<ol>
  <li>Двоичная(компиляция кода без перекомпиляции)
  <li>На уровне исходных кодов(перекомпиляция кода)
</ol>
Абстракция архитектуры
<ol>
  <li>Пользовательские программы
  <li>Ядро
  <li>Ассемблер  
  <li>Микрокод
  <li>Аппаратное обеспечение  
</ol>
Типы файлов UNIX:
<ol>
  <li>Символьные устройства
  <li>Блочные устройства  
  <li>Каталоги  
  <li>Ссылки  
  <li>Именованные каналы
  <li>Сокеты
</ol>

Символьные устройства - вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, с возможностью посимвольного обмена информацией. В отличие от блочного устройства символьное устройство, как правило, не обладает возможностями произвольного доступа.<br>

Ссылка в Unix-подобных системах — это своего рода указатель, напоминающий указатели в языках программирования, с той лишь разницей, что он указывает на файл или каталог.<br>

Сокет домена Unix (англ. Unix domain socket, UDS) или IPC-сокет (сокет межпроцессного взаимодействия) — конечная точка обмена данными, подобная Интернет-сокету, но не использующая сетевого протокола для взаимодействия (обмена данными). Используется в операционных системах, поддерживающих стандарт POSIX, для межпроцессного взаимодействия. Корректным термином стандарта POSIX является POSIX Local IPC Sockets.<br>

<h2>Командная строка</h2>
<ol>
<li>Исполняемые программы
<li>Функции
<li>Библиотечные вызовы
<li>Специальные файлы
<li>Форматы файлов
<li>Игры
<li>Пакеты макросов и соглашения
<li>Команды администрирования системы
<li>Процедуры ядра
<ol>
<h3>Редактирование и просмотр файлов</h3>
<ul>
<li>less- постраничный просмотр и поиск
<li>file, stat - информация о файле
<li>readlink - получить полное имя файлоа
<li>tail, head - просмотр конца и начала файла. Монитор логов
<li>vi/vim, emacs, nano, mcedit - редактирование текста
<li>split - разбить файл на несколько частей
</ul>
<h3>Файлы</h3>
<ul>
<li>touch - создание файла, если он не существует
<li>cp - копирование файла
<li>mv - перемещение/переименование файла
<li>ln - создает ссылки на файлы
<li>alias - создает алиас для команды
</ul>
<h3>Директории и навигация</h3>
<ul>
<li>cd - переход в другую директорию
<li>ls - отображает содержимое директории
<li>pwd - отображает текущую директорию
<li>readlink - полный путь к файлу
<li>rmdir - удаление директории
<li>mkdir - создание директории
<li>rm - удаление файлов
</ul>
<h3>Права файлов</h3>
<ul>
<li>Чтение
<li>Запись
<li>Исполнение
</ul>
<h3>Распространение прав пользователя</h3>
<ul>
<li>Владелец
<li>Группа
<li>Остальные
</ul>
Пользователь root имеет доступ на чтение и запись для любого файла<br>
Минимальные права для директории - 5(чтение и выполнение). Без прав на выполнение просмотр атрибутов файлов директории невозможен
<ul>
<li>rwx Чтение, запись и выполнение
<li>rw- Чтение и запись
<li>r-x Чтение и выполнение 
<li>r-- Только чтение
</ul>
 <ul>
<li>w - показывает, кто залогинен и че он занят
<li>who - Показывает, кто залогинен
<li>wall - отправляет бродкаст-сообщение на все терминалы
<li>useradd - утилита создание пользователя
<li>userdel - утилита удаления пользователя
<li>usermod - утилита изменения аккаунтов пользователя
<li>date - просмотр и установка даты
<li>cal - простой календарь
</ul>
<h3>Поток ввода/вывода</h3>
STDIN(0) - Стандартный ввод. Файл, из которого осуществляется чтение. <br>
STDOUT (1) - стандартный вывод. Файл, в который осуществляется запись. <br>
STFERR (2) - Стандартный поток ошибок. Файл, в который осуществляется запись сообщений об ошибках<br>
Перенаправление ввода с клавиатуры в файл: command < filename<br>
  “l” symlink символическая ссылка. С помощью символических ссылок администратор может присвоить одному файлу или директории несколько идентичностей. Символическая ссылка является указателем на оригинальный файл. Существует два типа символических ссылок: - жесткие ссылки; - мягкие ссылки.<br>
Различие между твердыми и мягкими ссылками в том, что мягкие ссылки ссылаются на имя файла, в то время как жесткие ссылки прямо ссылаются на оригинальный файл. Кроме того, жесткие ссылки не работают с файлами, расположенными на других разделах или файловых системах.<br>

  
  <h1>Устройства</h1>
<p>Устройства делятся на два типа:<p>
  <ul>
  <li>Символьные устройства - последовательный поток данных байт за байтом. Только одна позиция текущая. Невозможно обратиться к случайным данным.
  <li>Блочные устройства - позволяют обращаться к данным случаным образом(не последовательно). Блочные устройства чувствительны к производительности. Должны иметь возможность представлять доступ по любому адресу в устройстве.
  </ul>
  <p>Сектор - наименьший адресуемый элемент блочного устройства. Стандартый размер - 512 байт(в современных дисках - 4кб). Устройство не может работать с элементом данных размером менее сектора. Для ядра и ПО минимально адресуемая еденица данных для блочного устройства - блок. Размер сектора кратен размеру блока(512б, 1кб, 4кб). Размер блока не больше размера страницы памяти.</p>
  <h3>Устройства</h3>
  <p>Файловая система отправляет запросы к устройству в очередь.</p>
  <p>Очередь содержит список запросов на ввод/вывод и управляющую информацию.</p>
  <p>Пока очередь не пуста, драйвер устройства извлекает запросы из очереди и отправляет на блочное устройство</p>
  <h3>Файловые системы</h3>
  <p>Файловая система - способ отображения физических данных в файлы.</p>
  <p>Задачи файловой системы:</p>
  <ul>
  <li>Отображение логического представления файлов на физическое(сектора на блочном устройстве)
  <li>Реализация пользовательского интерфейса для доступа к файлам
  <li>Упорядочивание файлов
  <li>Защита данных в случае аппаратного сбоя
  <li>Реализация контроля доступа к файлам
  </ul>
  <h3>Иерархия файловой системы</h3>
  <p>В Windows иерархия файловой системы начинается с имени логического диска</p>
  <p>В Linux иерархия представляет единое дерево:</p>
  <ul>
  <li>/ - корень файловой системы
  <li>/boot - файлы загрузчика и ядро
  <li>/etc - конфигурационные файлы
  <li>/usr, /usr/local - программы пользователя
  <li>/bin, /usr/bin - исполняемые файлы
  <li>/home - домашние каталоги пользователей
  </ul>
  
  <h3>Абсолютные и относительные пути к файлу</h3>
  <p>Имена файлов и директорий регистрозависимы. Файлы Temp.txt и temp.txt - это разные файлы.</p>
  <p>Абсолютный путь к файлу - путь от корня файловой системы</p>
  <p>Относительный путь к файлу - путь от некорневого католога</p>
  
  <h3>Основные элементы файловой системы: inode</h3>
  <p>Индексный дискриптор(inode) содержит метаданные о файлах. Одному файлу соответствует один inode.</p>
  <p>inode содержит:</p>
  <ul>
  <li>Тип файла, атрибуты и правда доступа
  <li>Идентификатор владельца и группы
  <li>Число ссылок на файл
  <li>Массив адресов блоков файла
  <li>Время доступа к файлу, модификация файла, модификации inode
  </ul>
  <p>Не содержит:</p>
  <ul>
  <li>Имя файла(содержится в блоке данных каталога, который также имеет свой inode)
  <li>Данные файла(содержатся в блоках данных файла)
  </ul>
  
  <h3>Типы файлов:</h3>
  <ul>
  <li>Обычные файлы
  <li>Директории
  <li>Ссылки
  <li>Сокеты
  <li>Каналы
  <li>Файлы символьного устройства
  <li>Файлы блочного устройства
  </ul>
  
  <h3>Прерывания. Планировщик процессов</h3>
  <h3>Сигналы</h3>
  <p>Сигналы - способ оповестить процесс о наступлении события. Используются для управления процессами и межпроцессорного взаимодействия.</p>
  <p>Каждый сигнал имеет обработчик по умолчанию и действие по умолчанию.</p>
  <p>Обработчик сигнала можно переопределить.</p>
  <p>Сигналы можно игнорировать, кроме SIGKILL и SIGSTOP.</p>
  
  <h3>Прерывания</h3>
  <p>Прерывания - события, требующие немедленной реакции со стороны со стороны процессора</p>
  <p>Виды прерываний:</p>
  <ul>
  <li>Аппаратные - поступают от устройств в любой момент времени
  <li>Программные - возникают при выполнении программы, синхронно.
  <li>Маскируемые - процессор может игнорировать или откладывать их обработку 
  <li>Немаскируемые - не могут быть проигнорированы
  </ul>
  <p>Обычно связаны с аппаратными сбоями: ошибки датчика температуры, ошибки контроллера памяти</p>
    
<h3>Планировщик процессов</h3>
<p>Планировщик - компонент ядра, который определяет следующий процесс на выполнение. Планировщик определяет из списка готовых к выполнению задач наиболее подходящую. Процессы, не готовые к выполнению блокируются, используя ядро.</p>
    <h3>Вытеснение процесса</h3>
    <p>Linux - ОС с вытесняющей многозадачностью.</p>
    <ul>
      <li>Процесс A выполняется
      <li>Процесс B переходит в статус "готов к выполнению"
      <li>Ядро обнаруживает, что B имеет приоритет больше, чем A
      <li>Вызывается планировщик, вытесняет процеcc A
      <li>Процесс B ставится на выполнение
    </ul>
    
<h3>Синхронизация процессов в ОС</h3>
<p>Синхронизация процессов, определяется как механизм, который гарантирует, что два или более параллельных процесса или потока не смогут одновременно выполнить определенный сегмент программы, т.н. критическую секцию. Доступ процессов в критическую секцию осуществляется с помощью методов синхронизации. Когда кто-то приступает к выполнению критических секций (по частям сегмент программы) другой поток должен ждать, пока первый поток не завершит. Если синхронизация применяется неправильно может возникнуть состояние гонки, в котором значения переменных могут измениться непредсказуемо и изменяться в зависимости от времени переключения процессов или потоков.</p>
    
<h3>Мьютексы</h3>
<p>Мьютекс - примитив синхронизации, обеспечивающий взаимное исключение исполнения критических участков кода. Классический мьютекс отличается от двоичного семафора наличием эксклюзивного владельца, который и должен его освобождать (т.е. переводить в незаблокированное состояние). От спинлока мьютекс отличается передачей управления планировщику для переключения потоков при невозможности захвата мьютекса. Встречаются также блокировки чтения-записи, именуемые разделяемыми мьютексами и предоставляющие помимо эксклюзивной блокировки общую, позволяющую совместно владеть мьютексом, если нет эксклюзивного владельца.</p>

<p>Условно классический мьютекс можно представить в виде переменной, которая может находиться в двух состояниях: в заблокированном и в незаблокированном. При входе в свою критическую секцию поток вызывает функцию перевода мьютекса в заблокированное состояние, при этом поток блокируется до освобождения мьютекса, если другой поток уже владеет им. При выходе из критической секции поток вызывает функцию перевода мьютекса в незаблокированное состояние. В случае наличия нескольких заблокированных по мьютексу потоков во время разблокировки планировщик выбирает поток для возобновления выполнения (в зависимости от реализации это может быть, как случайный, так и детерминированный по некоторым критериям поток).</p>

<p>Задачей мьютекса является защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. Если другому потоку будет нужен доступ к данным, защищённым мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён. Мьютекс защищает данные от повреждения в результате асинхронных изменений (состояние гонки), однако при неправильном использовании могут порождаться другие проблемы, например, взаимная блокировка или двойной захват.</p>
<p>По типу реализации мьютекс может быть быстрым, рекурсивным или с контролем ошибок.</p>
    
<h3>Семафоры</h3>
<p>Семафор - примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся. Служит для построения более сложных механизмов синхронизации и используется для синхронизации параллельно работающих задач, для защиты передачи данных через разделяемую память, для защиты критических секций, а также для управления доступом к аппаратному обеспечению.</p>

<p>Вычислительные семафоры используются для контроля над ограниченными ресурсами. Двоичные семафоры обеспечивают взаимное исключение исполнения критических секций[4], а их упрощённой реализацией являются мьютексы, которые более ограничены в использовании. Помимо взаимного исключения в общем случае семафоры и мьютексы могут использоваться во множестве других типовых алгоритмов, включая сигнализирование другим задачам, разрешение прохождения определённых контрольных точек только для одной задачи единовременно по аналогии с турникетом, задачу производителя и потребителя, подразумевающую передачу данных от одних задач другим, барьеры, позволяющие синхронизировать группы задач в определённых контрольных точках, условные переменные для оповещения других задач о каких-либо событиях и блокировки чтения и записи, разрешающие одновременное чтение данных, но запрещающих их одновременное изменение</p>

<p>Типовыми проблемами использования семафоров являются одновременное блокирование двух задач в ожидании друг друга[ и ресурсное голодание, в результате чего ресурс может быть периодически недоступен для одних задач из-за его использования другими задачами. При использовании в процессах с приоритетом реального времени может возникнуть инверсия приоритетов, которая может привести к неограниченной по времени блокировке процесса с более высоким приоритетом из-за захвата семафора процессом с более низким приоритетом, в то время как процессорное время отдаётся процессу со средним приоритетом, решением чего является наследование приоритетов.</p>    
    
<h3>Критические секции</h3>
<p>Критическая секция (critical section) - это участок кода, требующий монопольного доступа к каким-то общим данным (ресурсам), которые не должен быть одновременно использованы более чем одним потоком исполнения. При нахождении в критической секции более одного процесса возникает состояние «гонки». Для избежания данной ситуации необходимо выполнение четырех условий:</p>
<ul>
<li>Два процесса не должны одновременно находиться в критических областях.
<li>В программе не должно быть предположений о скорости или количестве процессоров.
<li>Процесс, находящийся вне критической области, не может блокировать другие процессы.
<li>Невозможна ситуация, в которой процесс вечно ждет попадания в критическую область.    
</ul>    
<h3>Файловые блокировки</h3>
<p>Блокировка файла (англ. file locking) — механизм, который ограничивает доступ к файлу, давая доступ в данный момент только одному пользователю или процессу. Системы реализуют блокировку для предотвращения классического interceding update сценария (который является типичным примером состояния гонки) посредством принуждения к последовательным процессам обновления любого файла.</p>

<p>Следующий пример демонстрирует проблему interceding update:</p>
<ul>
<li>Процесс A читает запись о клиенте из файла, содержащего бухгалтерскую информацию, включая остаток денег на счете клиента и его номер телефона.
<li>Процесс B тогда же читает ту же самую запись из того же файла, так что у него есть своя копия записи.
<li>Процесс A изменяет остаток на счете в своей копии записи и записывает её обратно в файл.
<li>Процесс B, который все ещё имеет изначальное значение остатка на счете в своей копии записи, обновляет остаток и пишет обратно в файл.
<li>В итоге процесс B записал свое неактуальное значение остатка в файл, приведя к потере изменений, сделанных процессом A.
</ul>
<p>Неправильное использование блокировки файла, как и любой блокировки, может привести к снижению производительности или взаимной блокировке.</p>
  

  
  <h1>RabbitMQ</h1>
  <p>RabbitMQ - это брокер сообщений с открытым исходным кодом.</p>
  <p>кратко работу RabbitMQ можно описать следующим образом:</p>
  <ul>
    <li>Издатель отправляет сообщение определенном обменику;
    <li>Обменник, получив сообщение, маршрутизирует его в одну или несколько очередей в соответствии с правилами привязки между ними и очередью;
    <li>Очередь хранит ссылку на это сообщение. Само сообщение хранится в оперативной памяти или на диске;
    <li>Как только потребитель готов получить сообщение из очереди, сервер создает копию сообщения по ссылке и отправляет её;
    <li>Потребитель получает сообщение и отправляет брокеру подтверждение;
    <li>Брокер, получив подтверждение, удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти и с диска.
  </ul>
  
  <h3>Docker</h3>
  <p>Docker - программное обеспечение с открытым исходным кодом, применяемое для разработки, тестирования, доставки и запуска веб-приложений в средах с поддержой контейнеризации. Он нужен для более эффективного использовния системных ресурсов, быстрого развертывания готовых программных продуктов, а также для их масштабирования и переноса в другие среды с гарантированным сохранением стабильной работы</p>

  <h3>Компоненты Docker</h3>
  <p>Docker-демон - сервер контейнеров, входящий в состав программных средств Docker. Демон управляет Docker-объектами(сети, хранилища, образы и контейнеры)</p>
  <p>Docker-клиент(Docker-client/CLI) - интерфейс взаимодействия пользователя с Docker-демоном.</p>
  <p>Docker-образ(Docker-image) - файл, включающий зависимости, сведения, конфигурацию для дальнейшего развертывания и инициализации контейнера.</p>
  <p>Docker-файл(Docker-file) - описание правил по сборке образа, в котором первая строка указывает на базовый образ. Последующие команды выполняют копирование файлов и установку программ для создания определенной среды для разработки.</p>
  <p>Docker-контейнер(Docker-container) - это легкий, автономный исполняемый пакет программного обеспеспечения, который включает в себя все необходимое для запуска приложения: код, среду выполнения, системные иструменты, системные библиотеки и настройки.</p>
  
  <h3>Как работает Docker</h3>
  <p>Пользователь отдает команду с помощью пользовательского интерфейсу Docker-демону, развернутому на Docker-хосте. Например, скачать готовый образ из реестра (хранилища docker-образов)</p>
  
  <h3>Что происодит при запуске контейнера</h3>
  <p>Происходит запуска образа (Docket-image), Docker Engine проверяет существование образа. Если образ уже существует локально, Docker использует его для нового конейнера. При его отсутствии выполняется скачивание с Docker Hub.</p>
  
  <h3>InfluxDB</h3>
  <p>InfluxDB - БД временных рядов, предстваляют собой системы баз данных, специально предназначенные для обработки информации, связанной со временем.</p>
  
  <h3>Зачем нужны базы данных временных рядов</h3>
  <p>При добавлении новых записей в реляционную БД и при наличии в таблице индексов СУБД ьудет многократно переиндексирвоать данные для быстрого и эффективого доступа к ним. Как следствие, производительность со временем снижается. При этом увеличивается нагрузка, что приводит к трудностям при чтении данных.</p>
  <p>База данных временных рядов оптимизирована для быстрого приёма данных. Такие системы используют индексацию данных, объединенных со временем. Как следствие, скорость загрузки не уменьшается со временем и остается достаточно </p>
